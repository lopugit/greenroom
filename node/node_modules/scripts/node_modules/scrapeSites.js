let sites = require('sites')
let s = require('smarts')()
let sentience = require('sentience')
let secrets = require('secrets')
let monk = require('monk')(sentience['uri.js'](secrets.mdb))

let growlights = monk.get('growlights/things')
let db = require('db')({
	schemas: sites.schemas()
})

let exp = async function(args){
	if(args.muppets){
		if(s.getsmart(global, 'logging.timing', false)){
			console.log(`Starting scrape at ${Date()}`)
		}
		let muppets = await args.muppets
		let startTime = process.hrtime()
		let promises = []
		for await(let site of sites){
			let sitePageIds = Object.keys(site)
			for(let pageId of sitePageIds){
				let muppet = await muppets.available()
				let url = site[pageId].createUrl({self: site[pageId]})
				promises.push(
					// await muppet.page.goto(url, { timeout: 100000 })
					muppet.page.goto(url, { timeout: 100000 })
					.catch(console.error)
					.then(async ()=>{
						await muppet.page.waitForSelector(site[pageId].list.id+" > *").catch(console.error)
						let els = await muppet.page.$$(site[pageId].list.id+" > *").catch(console.error)
						if(els && els.length){
							for(let el of els){
								let obj = {}
								let properties = site[pageId].schema.properties
								let monkModel = monk.get(site[pageId].schema.path)
								let model = db.models[site[pageId].schema.path]
								let schema = site[pageId].schema
								await scrapeProperties({properties, obj, muppet, model, schema, el}).catch(console.error)
								await site[pageId].schema.ai({obj, schema}).catch(console.error)
								let query = {
									title: obj.title
								}
								let newObj = new model(obj)
								let err = await newObj.validate().catch(err=>{
									if(err && s.getsmart(global, 'logging.mongoose', false)){
										console.error('something went wrong validating the model: ', err)
									}
									return err
								})
								if(!err){
									var test = obj
									await monkModel.findOneAndUpdate(
										query,
										obj,
										{
											upsert: true
										}
									)	
									.then(updated=>{
										if(s.getsmart(global, 'logging.mongoose.write', false)){
											console.log(`Scraped ${updated.title}`)
											console.log(`From ${updated.source}`)
											console.log(`To ${schema.path}`)
										}
									})
									.catch(err=>{
										if(err && global.logging && global.logging.mongoose){
											console.error(err)
										}
									})
								} else {
									console.error(err)
								}
							}
						} else {
							console.log('no products to scrape')
						}
						muppet.available()
					})
				)
			}
		}
		Promise.all(promises).then(()=>{
			let finishTime = process.hrtime(startTime)
			if(global.logging && global.logging.timing){
				console.log(`Done! Took ${finishTime[0]} seconds`)
				return
			}
		})
	}
}

module.exports = exp

// funcs
async function scrapeProperties(args){
	for await(let property of args.properties){
		let parentPaths = []
		if(property.path){
			parentPaths.push(property.path)
		}
		if(s.getsmart(property, 'html.properties', false) && s.getsmart(args, 'schema.schema.properties', false)){
			let parallelProperty = s.getThing({
				option: { 
					path: property.path
				}, 
				list: s.gosmart(args, 'schema.schema.properties', []), 
				keys: ['path']
			})
			if(typeof property.path !== 'undefined' && s.getsmart(parallelProperty, 'mongoose', false)){
				// if the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
				if(typeof parallelProperty.mongoose.schema.type == 'undefined'){
					// the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
					// if the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
					if(typeof parallelProperty.mongoose.schema !== 'function'){
						// the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
						// unlikely
						args.obj[property.path] = parallelProperty.mongoose.schema.constructor()
					} 
					// if the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
					else {
						// the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
						args.obj[property.path] = new parallelProperty.mongoose.schema()
					}
				} 
				// if the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
				else if(typeof parallelProperty.mongoose.schema.type !== 'function'){
					// the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
					args.obj[property.path] = parallelProperty.mongoose.schema.type.constructor()
				} else {
					args.obj[property.path] = new parallelProperty.mongoose.schema()
				}
				await scrapeProperties({
					...args, 
					parentPaths, 
					properties: property.html.properties, 
					obj: args.obj[property.path]
				}).catch(console.error)
			}
		} else if(property.html || property.parser || property.val){
			await getVal({...args, property, obj: args.obj})
		}
	}
	return args.obj
}

async function getVal(args){
	let toEval
	if(s.getsmart(args, 'property.html.page', false)){
		toEval = args.muppet.page
	} else {
		toEval = args.el
	}
	let val = undefined
	if(s.getsmart(args, 'property.html.selector', false)){
		val = await toEval.$eval(args.property.html.selector, (element, attribute)=>{
			return element[attribute]
		}, args.property.html.attribute || 'innerText').catch((err)=>{})
	}
	val = args.property.parser ? args.property.parser({val, property: args.property}) : val
	let err = 1
	let path = args.property.path
	if(!path && args.parentPaths.length){
		path = args.parentPaths[args.parentPaths.length-1]
	}
	if(typeof path !== 'undefined' && args.model){
		let testObj = new args.model({})
		if(testObj[path] instanceof Array){
			testObj[path].push(val)
		} else {
			testObj[path] = val
		}
		err = await testObj.validate().catch(err=>{
			if(err && global.logging && global.logging.mongoose && global.logging.mongoose.values){
				console.error(err)
			}
		})
		if(!err){
			if(args.obj instanceof Array && typeof val !== 'undefined'){
				args.obj.push(val)
			} else {
				args.obj[args.property.path] = val
			}
		}
	}
	return
}