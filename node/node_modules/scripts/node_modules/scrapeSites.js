let sites = require('sites')
let s = require('smarts')()
let functions = require('functions')
let secrets = require('secrets')
let uri = functions['uri.js'](secrets.mongoDB)
console.log("[muppets][info] Connecting via monk to URI "+uri)
let monk = require('monk')(uri)

let db = require('db')({
	schemas: sites.schemas()
})

let toExport = async function(args){
	if(args.muppets){
		console.log(`[muppets][info] Starting scrape at ${Date()}`)
		let time = new Date().getTime()
		let startTime = process.hrtime()
		let collections = ["growtime/dev/products"]
		try {
			let promises = []
			console.log(`[muppets][info] Scraping ${sites.length} sites`)
			let muppets = await args.muppets
			for await(let site of sites) {
				try {
					console.log(`[muppets][info] Scraping ${site.name}`)
					let pages = site.pages
					let pageIds = Object.keys(site.pages)
					for (let pageId of pageIds){
						try {
							let muppet = await muppets.available()
							let url = pages[pageId].createUrl({self: pages[pageId]})
							muppet.page = await muppet.getBrowser().newPage()
							let promise = muppet.page.goto(url, { timeout: 1000*15 })
							promises.push(
								promise
							)
							// fake multi threading
							promise
							.then(async ()=>{
								try {
									await muppet.page.waitForSelector(pages[pageId].list.selector+" > *", { timeout: 1000*2 })
									let els = await muppet.page.$$(pages[pageId].list.selector+" > *")
									if(!els || !els.length){
										console.log('[muppets][info] No products to scrape')
									} else {
										for await(let el of els){
											try {
												let obj = {
													site: site.name
												}
												let properties = pages[pageId].schema.properties
												console.log(`[muppets][info] Using collection ${pages[pageId].schema.path}`)
												let monkCollection = monk.get(pages[pageId].schema.path)
												collections.push(pages[pageId].schema.path)
												let model = db.models[pages[pageId].schema.path]
												let schema = pages[pageId].schema
												await scrapeProperties({properties, obj, muppet, model, schema, el})
												await pages[pageId].schema.ai({obj, schema})
												let query = {
													title: obj.title
												}
												obj.updated = time
												let newObj = new model(obj)
												console.log("[muppets][info] Validating newObj")
												await newObj.validate()
												let exists = await monkCollection.findOne(query)
												if (!exists) {
													obj.created = time
												}
												let updated = await monkCollection.findOneAndUpdate(
													query,
													{ $set: obj },
													{
														upsert: true
													}
												)	
												if(s.getsmart(global, 'logging.mongoose.write', false)){
													console.log(`[muppets][info] Scraped ${updated.title}`)
													console.log(`[muppets][info] From ${updated.source}`)
													console.log(`[muppets][info] To ${schema.path}`)
												}
											} catch (err) {
												console.error("[muppets][error] ", err)
											}
										}
									}
								} catch (err) {
									console.error("[muppets][error] ", err)
								}
							})
							.catch(err=>{
								console.error("[muppets][error] ", err)
								return err
							})
							.finally(()=>{
								console.log("[muppets][info][muppet] Making muppet available again")
								muppet.available()
								muppet.page.close()
							})
						} catch (err) {
							console.error("[muppets][error] ", err)
							muppet.pageCrash()
						}
					}
				} catch (err) {
					console.error("[muppets][error] ", err)
				}
			}
			await Promise.all(promises)
			let finishTime = process.hrtime(startTime)
			console.log(`[muppets][info] Done! Took ${finishTime[0]} seconds`)
			console.log("[muppets][info][deletion] Deleting all old products from", collections.length, "collections")
			// do this incase not all scraped things are from the same collection
			for (let collection of collections) {
				try {
					console.log("[muppets][info][deletion] Deleting all old products from", collection)
					let monkCollection = monk.get(collection)
					let count = await monkCollection.remove({
						$or: [
							{
								updated: {
									$lt: time
								},
							},
							{
								updated: {
									$exists: false
								}
							}
						]
					})
					console.log("[muppets][info][deletion] Deleted", count)
				} catch (err) {
					console.error("[muppets][error] ", err)
				}
			}
		} catch (err) {
			console.error("[muppets][error]", err)
		}
	}
}

module.exports = toExport

// funcs
async function scrapeProperties(args){
	for await(let property of args.properties){
		let parentPaths = []
		if(property.path){
			parentPaths.push(property.path)
		}
		if(s.getsmart(property, 'html.properties', false) && s.getsmart(args, 'schema.schema.properties', false)){
			let parallelProperty = s.getThing({
				option: { 
					path: property.path
				}, 
				list: s.gosmart(args, 'schema.schema.properties', []), 
				keys: ['path']
			})
			if(typeof property.path !== 'undefined' && s.getsmart(parallelProperty, 'mongoose', false)){
				// if the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
				if(typeof parallelProperty.mongoose.schema.type == 'undefined'){
					// the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
					// if the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
					if(typeof parallelProperty.mongoose.schema !== 'function'){
						// the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
						// unlikely
						args.obj[property.path] = parallelProperty.mongoose.schema.constructor()
					} 
					// if the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
					else {
						// the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
						args.obj[property.path] = new parallelProperty.mongoose.schema()
					}
				} 
				// if the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
				else if(typeof parallelProperty.mongoose.schema.type !== 'function'){
					// the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
					args.obj[property.path] = parallelProperty.mongoose.schema.type.constructor()
				} else {
					args.obj[property.path] = new parallelProperty.mongoose.schema()
				}
				await scrapeProperties({
					...args, 
					parentPaths, 
					properties: property.html.properties, 
					obj: args.obj[property.path]
				})
			}
		} else if(property.html || property.parser || property.val){
			await getVal({...args, property, obj: args.obj})
		}
	}
	return args.obj
}

async function getVal(args){
	let toEval
	if(s.getsmart(args, 'property.html.page', false)){
		toEval = args.muppet.page
	} else {
		toEval = args.el
	}
	let val = undefined
	if(s.getsmart(args, 'property.html.selector', false)){
		val = await toEval.$eval(args.property.html.selector, (element, attribute)=>{
			return element[attribute]
		}, args.property.html.attribute || 'innerText').catch((err)=>{})
	}
	val = args.property.parser ? args.property.parser({val, property: args.property}) : val
	let err = 1
	let path = args.property.path
	if(!path && args.parentPaths.length){
		path = args.parentPaths[args.parentPaths.length-1]
	}
	if(typeof path !== 'undefined' && args.model){
		let testObj = new args.model({})
		if(testObj[path] instanceof Array){
			testObj[path].push(val)
		} else {
			testObj[path] = val
		}
		err = await testObj.validate().catch(err=>{
			console.error("[muppets][error][mongoose][validation]", err)
		})
		if(!err){
			if(args.obj instanceof Array && typeof val !== 'undefined'){
				args.obj.push(val)
			} else {
				args.obj[args.property.path] = val
			}
		}
	}
	return
}