let sites = require('sites')
let smarts = require('smarts')()
let db = require('db')({
	schemas: sites.schemas()
})

let exp = async function(args){
	if(args.muppets){
		if(global.logging && global.logging.timing){
			console.log(`Starting scrape at ${Date()}`)
		}
		let muppets = await args.muppets
		let startTime = process.hrtime()
		let promises = []
		for(let site of sites){
			let sitePageIds = Object.keys(site)
			for(let pageId of sitePageIds){
				let muppet = await muppets.available()
				let url = site[pageId].createUrl({self: site[pageId]})
				promises.push(
					muppet.page.goto(url, { timeout: 100000 })
					.then(async ()=>{
						await muppet.page.waitForSelector(site[pageId].list.id+" > *").catch(console.error)
						let els = await muppet.page.$$(site[pageId].list.id+" > *").catch(console.error)
						if(els && els.length){
							for(let el of els){
								let obj = {}
								let properties = site[pageId].schema.properties
								let model = db.models[site[pageId].schema.path]
								let schema = site[pageId].schema
								await scrapeProperties({properties, obj, muppet, model, schema, el}).catch(console.error)
								await site[pageId].schema.ai({obj, schema}).catch(console.error)
								let query = {
									title: obj.title
								}
								let newObj = new model(obj)
								let err = await newObj.validate().catch(err=>{
									if(err && global.logging && global.logging.mongoose){
										console.error(err)
									}
								})
								if(!err){
									var test = obj
									await model.findOneAndUpdate(
										query,
										obj,
										{
											upsert: true,
											new: true
										},
										async (err, dbObj)=>{
											if(!err){
												if(global.logging && global.logging.mongoose && global.logging.mongoose.write){
													console.log(`Scraped ${dbObj.title}`)
												}
												// console.log(dbObj)
											} else {
												console.log(test)
												if(err && global.logging && global.logging.mongoose){
													console.error(err)
												}
											}
											return
										}
									)	
								} else {
									console.error(err)
								}
							}
						} else {
							console.log('no products to scrape')
						}
						muppet.available()
					})
					.catch(console.error)
				)
			}
		}
		Promise.all(promises).then(()=>{
			let finishTime = process.hrtime(startTime)
			if(global.logging && global.logging.timing){
				console.log(`Done! Took ${finishTime[0]} seconds`)
				return
			}
		})
	}
}

module.exports = exp

// funcs
async function scrapeProperties(args){
	for await(let property of args.properties){
		let parentPaths = []
		if(property.path){
			parentPaths.push(property.path)
		}
		if(property.html && property.html.properties && args.schema.schema.properties){
			let parallelProperty = smarts.getThing({option: { path: property.path}, list: args.schema.schema.properties, keys: ['path']})
			if(typeof property.path !== 'undefined' && parallelProperty && parallelProperty.mongoose){
				if(typeof parallelProperty.mongoose.schema.type == 'undefined'){
					// the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
					if(typeof parallelProperty.mongoose.schema !== 'function'){
						// the type of the object path is defined by the value of the schema path value itself, ie path: {} or path: []
						// unlikely
						args.obj[property.path] = parallelProperty.mongoose.schema.constructor()
					} else {
						// the type of the object path is defined as a key word, Object, String, Number, etc.. use the new keyword
						args.obj[property.path] = new parallelProperty.mongoose.schema()
					}
				} else if(typeof parallelProperty.mongoose.schema.type !== 'function'){
					// the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
					args.obj[property.path] = parallelProperty.mongoose.schema.type.constructor()
				} else {
					args.obj[property.path] = new parallelProperty.mongoose.schema()
				}
				await scrapeProperties({...args, parentPaths, properties: property.html.properties, obj: args.obj[property.path]}).catch(console.error)
			}
		} else if(property.html){
			await getVal({...args, property, obj: args.obj})
		}
	}
	return args.obj
}

async function getVal(args){
	let toEval
	if(args.property.html.page){
		toEval = args.muppet.page
	} else {
		toEval = args.el
	}
	let val = undefined
	if(args.property.html.selector){
		val = await toEval.$eval(args.property.html.selector, (element, attribute)=>{
			return element[attribute]
		}, args.property.html.attribute || 'innerText').catch((err)=>{})
	}
	val = args.property.parser ? args.property.parser({val, property: args.property}) : val
	let err = 1
	let path = args.property.path
	if(!path && args.parentPaths.length){
		path = args.parentPaths[args.parentPaths.length-1]
	}
	if(typeof path !== 'undefined' && args.model){
		let testObj = new args.model({})
		if(testObj[path] instanceof Array){
			testObj[path].push(val)
		} else {
			testObj[path] = val
		}
		err = await testObj.validate().catch(err=>{
			if(err && global.logging && global.logging.mongoose && global.logging.mongoose.values){
				console.error(err)
			}
		})
		if(!err){
			if(args.obj instanceof Array && typeof val !== 'undefined'){
				args.obj.push(val)
			} else {
				args.obj[args.property.path] = val
			}
		}
	}
	return
}