let sites = require('sites')
let s = require('smarts')()
let functions = require('functions')
let secrets = require('secrets')
let uri = functions['uri.js'](secrets.mongoDB)
rollbar.log("Connecting via monk to URI "+uri)
let monk = require('monk')(uri)

let db = require('db')({
	schemas: sites.schemas()
})

let toExport = async function(args){
	if(args.muppets){
		if(s.getsmart(global, 'logging.timing', false)){
			rollbar.log(`Starting scrape at ${Date()}`)
		}
		let muppets = await args.muppets
		let startTime = process.hrtime()
		let promises = []
		rollbar.log(`Scraping ${sites.length} sites`)
		for await(let site of sites){
			rollbar.log(`Scraping ${site.name}`)
			let pages = site.pages
			let pageIds = Object.keys(site.pages)
			for(let pageId of pageIds){
				let muppet = await muppets.available()
				let url = pages[pageId].createUrl({self: pages[pageId]})
				promises.push(
					// await muppet.page.goto(url, { timeout: 100000 })
					muppet.page.goto(url, { timeout: 100000 })
					.catch((e)=>rollbar.error(e))
					.then(async ()=>{
						await muppet.page.waitForSelector(pages[pageId].list.selector+" > *").catch((e)=>rollbar.error(e))
						let els = await muppet.page.$$(pages[pageId].list.selector+" > *").catch((e)=>rollbar.error(e))
						if(els && els.length){
							for(let el of els){
								let obj = {
									site: site.name,
									dateUpdated: Date.now()
								}
								let properties = pages[pageId].schema.properties
								rollbar.log(`Using collection ${pages[pageId].schema.path}`)
								let monkModel = monk.get(pages[pageId].schema.path)
								let model = db.models[pages[pageId].schema.path]
								let schema = pages[pageId].schema
								await scrapeProperties({properties, obj, muppet, model, schema, el}).catch((e)=>rollbar.error(e))
								await pages[pageId].schema.ai({obj, schema}).catch((e)=>rollbar.error(e))
								let query = {
									title: obj.title
								}
								let newObj = new model(obj)
								let err = await newObj.validate().catch(err=>{
									if(err && s.getsmart(global, 'logging.mongoose', false)){
										rollbar.error('something went wrong validating the model: ', err)
									}
									return err
								})
								if(!err){
									await monkModel.findOneAndUpdate(
										query,
										{ $set: obj },
										{
											upsert: true
										}
									)	
									.then(updated=>{
										if(s.getsmart(global, 'logging.mongoose.write', false)){
											rollbar.log(`Scraped ${updated.title}`)
											rollbar.log(`From ${updated.source}`)
											rollbar.log(`To ${schema.path}`)
										}
									})
									.catch(err=>{
										if(err && global.logging && global.logging.mongoose){
											rollbar.error(err)
										}
									})
									let test = 1
								} else {
									rollbar.error(err)
								}
							}
						} else {
							rollbar.log('no products to scrape')
						}
						muppet.available()
					})
				)
			}
		}
		Promise.all(promises).then(()=>{
			let finishTime = process.hrtime(startTime)
			if(global.logging && global.logging.timing){
				rollbar.log(`Done! Took ${finishTime[0]} seconds`)
				return
			}
		})
	}
}

module.exports = toExport

// funcs
async function scrapeProperties(args){
	for await(let property of args.properties){
		let parentPaths = []
		if(property.path){
			parentPaths.push(property.path)
		}
		if(s.getsmart(property, 'html.properties', false) && s.getsmart(args, 'schema.schema.properties', false)){
			let parallelProperty = s.getThing({
				option: { 
					path: property.path
				}, 
				list: s.gosmart(args, 'schema.schema.properties', []), 
				keys: ['path']
			})
			if(typeof property.path !== 'undefined' && s.getsmart(parallelProperty, 'mongoose', false)){
				// if the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
				if(typeof parallelProperty.mongoose.schema.type == 'undefined'){
					// the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
					// if the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
					if(typeof parallelProperty.mongoose.schema !== 'function'){
						// the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
						// unlikely
						args.obj[property.path] = parallelProperty.mongoose.schema.constructor()
					} 
					// if the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
					else {
						// the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
						args.obj[property.path] = new parallelProperty.mongoose.schema()
					}
				} 
				// if the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
				else if(typeof parallelProperty.mongoose.schema.type !== 'function'){
					// the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
					args.obj[property.path] = parallelProperty.mongoose.schema.type.constructor()
				} else {
					args.obj[property.path] = new parallelProperty.mongoose.schema()
				}
				await scrapeProperties({
					...args, 
					parentPaths, 
					properties: property.html.properties, 
					obj: args.obj[property.path]
				}).catch((e)=>rollbar.error(e))
			}
		} else if(property.html || property.parser || property.val){
			await getVal({...args, property, obj: args.obj})
		}
	}
	return args.obj
}

async function getVal(args){
	let toEval
	if(s.getsmart(args, 'property.html.page', false)){
		toEval = args.muppet.page
	} else {
		toEval = args.el
	}
	let val = undefined
	if(s.getsmart(args, 'property.html.selector', false)){
		val = await toEval.$eval(args.property.html.selector, (element, attribute)=>{
			return element[attribute]
		}, args.property.html.attribute || 'innerText').catch((err)=>{})
	}
	val = args.property.parser ? args.property.parser({val, property: args.property}) : val
	let err = 1
	let path = args.property.path
	if(!path && args.parentPaths.length){
		path = args.parentPaths[args.parentPaths.length-1]
	}
	if(typeof path !== 'undefined' && args.model){
		let testObj = new args.model({})
		if(testObj[path] instanceof Array){
			testObj[path].push(val)
		} else {
			testObj[path] = val
		}
		err = await testObj.validate().catch(err=>{
			if(err && global.logging && global.logging.mongoose && global.logging.mongoose.values){
				rollbar.error(err)
			}
		})
		if(!err){
			if(args.obj instanceof Array && typeof val !== 'undefined'){
				args.obj.push(val)
			} else {
				args.obj[args.property.path] = val
			}
		}
	}
	return
}