let sites = require('sites')
let s = require('smarts')()
let functions = require('functions')
let secrets = require('secrets')
let uri = functions['uri.js'](secrets.mongoDB)
let { DateTime } = require('luxon')

global.logger.log("[greenroom][scrapeSites][info] Connecting via monk to URI "+uri)
let monk = require('monk')(uri)

let db = require('db')({
	schemas: sites.schemas()
})

module.exports = {
	schedule: {
		minutes: 5
	},
	enabled: true,
	name: "Scrape Sites",
	run: async function (args){
		let actors = await require('actors')()
		try {
			global.logger.log(`[greenroom][scrapeSites][info] Starting scrape at ${Date()}`)
			let time = DateTime.now()
			let processTimer = process.hrtime()
			let totalProducts = 0
			let promises = []
			try {
				global.logger.log(`[greenroom][scrapeSites][info] Scraping ${sites.length} sites`)
				for await(let site of sites) {
					try {
						global.logger.log(`[greenroom][scrapeSites][info] Scraping ${site.name}`)
						let pages = site.pages
						let pageIds = Object.keys(site.pages)
						for (let pageId of pageIds){
							try {
								let page = pages[pageId]
								let actor = await actors.available()
								let url = page.createUrl({self: page})
								actor.pages.main = await actor.getBrowser().newPage()
								// fake multi threading
								let promise = actor.pages.main.goto(url, { timeout: 1000*15 })
								.then(async ()=>{
									try {
										await actor.pages.main.waitForSelector(page.list.selector+" > *", { timeout: 1000*2 })
										if (page.schema.clickthrough) {
											actor.pages.clickthrough = await actor.getBrowser().newPage()
										}
									} catch (err) {
										global.logger.error("[greenroom][scrapeSites][waitForSelector]", err.message)
										return
									}
									try {
										let elements = await actor.pages.main.$$(page.list.selector+" > *")
										if(!elements || !elements.length){
											global.logger.log('[greenroom][scrapeSites][info] No products to scrape')
										} else {
											for await(let element of elements){
												try {
													let obj = {
														site: site.name
													}

													let clickthroughUrl = await element.$eval(page.schema.clickthrough.html.selector, (element, attribute)=>{
														return element[attribute]
													}, page.schema.clickthrough.html.attribute || 'innerText').catch((err)=>{})

													await actor.pages.clickthrough.goto(clickthroughUrl, { timeout: 1000*15 })
													
													let properties = page.schema.properties
													global.logger.log(`[greenroom][scrapeSites][info] Using collection ${page.schema.path}`)
													let monkCollection = monk.get(page.schema.path)
													let model = db.models[page.schema.path]
													let schema = page.schema
													await scrapeProperties({properties, obj, actor, model, schema, el: element})
													await page.schema.ai({obj, schema})
													let query = {
														title: obj.title
													}
													obj.updated = time.toSeconds()
													let newObj = new model(obj)
													global.logger.log("[greenroom][scrapeSites][info] Validating newObj")
													await newObj.validate()
													let exists = await monkCollection.findOne(query)
													if (!exists) {
														obj.created = time.toSeconds()
													}
													let updated = await monkCollection.findOneAndUpdate(
														query,
														{ $set: obj },
														{
															upsert: true
														}
													)	
													global.logger.log(`[greenroom][scrapeSites][info] Scraped ${updated.title}`)
													global.logger.log(`[greenroom][scrapeSites][info] From ${updated.source}`)
													global.logger.log(`[greenroom][scrapeSites][info] To ${schema.path}`)
													totalProducts++
												} catch (err) {
													global.logger.error("[greenroom][scrapeSites][error]", err)
												}
											}
										}
									} catch (err) {
										global.logger.error("[greenroom][scrapeSites][error]", err)
									}
								})
								.catch(err=>{
									global.logger.error("[greenroom][scrapeSites][error]", err)
									return err
								})
								.finally(()=>{
									global.logger.log("[greenroom][scrapeSites][info] Making actor available again")
									actor.available()
								})
								promises.push(
									promise
								)
							} catch (err) {
								global.logger.error("[greenroom][scrapeSites][error]", err)
								actor.pageCrash()
							}
						}
					} catch (err) {
						global.logger.error("[greenroom][scrapeSites][error]", err)
					}
				}
			} catch (err) {
				global.logger.error("[greenroom][scrapeSites][error]", err)
			} finally {
				await Promise.all(promises)
				let finishTime = process.hrtime(processTimer)
				global.logger.log("[greenroom][scrapeSites][summary][info] Done! Took", finishTime[0], "seconds. Scraped", totalProducts, "products")
			}
		} catch (err) {
			global.logger.error("[greenroom][scrapeSites][error] ", err)
		} finally {
			global.logger.log("[greenroom][scrapeSites][actors][info] Closing actors")
			actors.close()
		}
	}
}

// funcs
async function scrapeProperties(args){
	for await(let property of args.properties){
		let parentPaths = []
		if(property.path){
			parentPaths.push(property.path)
		}
		if(s.getsmart(property, 'html.properties', false) && s.getsmart(args, 'schema.schema.properties', false)){
			let parallelProperty = s.getThing({
				option: { 
					path: property.path
				}, 
				list: s.gosmart(args, 'schema.schema.properties', []), 
				keys: ['path']
			})
			if(typeof property.path !== 'undefined' && s.getsmart(parallelProperty, 'mongoose', false)){
				// if the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
				if(typeof parallelProperty.mongoose.schema.type == 'undefined'){
					// the mongoose schema object doesn't have a type so we calculate type based on the schema path value itself
					// if the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
					if(typeof parallelProperty.mongoose.schema !== 'function'){
						// the type of the object is defined by the value of the schema value itself, ie schema: {} or schema: []
						// unlikely
						args.obj[property.path] = parallelProperty.mongoose.schema.constructor()
					} 
					// if the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
					else {
						// the type of the object is defined as a key word, Object, String, Number, etc.. use the new keyword
						args.obj[property.path] = new parallelProperty.mongoose.schema()
					}
				} 
				// if the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
				else if(typeof parallelProperty.mongoose.schema.type !== 'function'){
					// the mongoose schema object has a type property that isn't a keyword type like Object, String, etc.. so we can use the constructor to create the value
					args.obj[property.path] = parallelProperty.mongoose.schema.type.constructor()
				} else {
					args.obj[property.path] = new parallelProperty.mongoose.schema()
				}
				await scrapeProperties({
					...args, 
					parentPaths, 
					properties: property.html.properties, 
					obj: args.obj[property.path]
				})
			}
		} else if(property.html || property.parser || property.val){
			await getVal({...args, property, obj: args.obj})
		}
	}
	return args.obj
}

async function getVal(args){
	let toEval
	if(s.getsmart(args, 'property.html.page', false)){
		toEval = args.actor.pages.main
	} else if (s.getsmart(args, 'property.html.clickthrough')) {
		toEval = args.actor.pages.clickthrough
	} else {
		toEval = args.el
	}
	let val = undefined
	if(s.getsmart(args, 'property.html.selector', false)){
		val = await toEval.$eval(args.property.html.selector, (element, attribute)=>{
			return element[attribute]
		}, args.property.html.attribute || 'innerText').catch((err)=>{})
	}
	val = args.property.parser ? args.property.parser({val, property: args.property}) : val
	let err = 1
	let path = args.property.path
	if(!path && args.parentPaths.length){
		path = args.parentPaths[args.parentPaths.length-1]
	}
	if(typeof path !== 'undefined' && args.model){
		let testObj = new args.model({})
		if(testObj[path] instanceof Array){
			testObj[path].push(val)
		} else {
			testObj[path] = val
		}
		try {
			await testObj.validate()
		} catch (err) {
			if (err.message.indexOf("validation failed") >= 0) {
				throw new Error(err.message)
			} else {
				throw err
			}
		}
		if(args.obj instanceof Array && typeof val !== 'undefined'){
			args.obj.push(val)
		} else {
			args.obj[args.property.path] = val
		}
	}
	return
}