
let puppeteer = require('puppeteer')

module.exports = async function(args = {}){
	global.logger.log("[greenroom][actors] Getting actors ready")
	global.logger.log("[greenroom][actors][browser] Launching browser")
	let browser = await puppeteer.launch({
		headless: true,
		args: [
			"--unlimited-storage",
      "--full-memory-crash-report",
      "--disable-gpu",
      "--ignore-certificate-errors",
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--lang=en-US;q=0.9,en;q=0.8",
      "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
		]
	})
	let actors = {
		"ready": [],
		actors: [],
		min: args.actors || 1,
		"running": {},
		browser,
		async close(){
			global.logger.log("[greenroom][actors][browser] Closing browser")
			await browser.close()
		},
		init(args){
			this["find actors"]({number: args.min || this.min})
			this.log(args)
			this.poolAI(args)
			return this
		},
		max: args.max || 4,
		poolAI(args){
			this.poolAI.loop = this.poolAI.loop || setInterval(()=>{
				if(this["ready"].length < this.min && this.actors.length < this.max){
					this["find actors"]({number: this.min - this["ready"].length})
				}
			}, 100)
		},
		available(args){
			var args = args || {}
			return new Promise((resolve, reject)=>{
				let i = setInterval(()=>{
					if(this["ready"].length > 0){
						clearInterval(i)
						let actor = this["ready"].shift()
						let path = actor.id
						if(!this["running"][path]){
							this["running"][path] = actor
						}
						resolve(actor)
					}
				}, 50)
			})
		},
		"find actors": async function (args){
			if(typeof args.number !== undefined && typeof args.number == 'number' && !this.finding){
				global.logger.log(`[greenroom][actors][info] finding ${args.number} ${args.number == 1 ? 'actor' : 'actors'}`)
				this.finding = true
				let loop = new Array(args.number).fill(0)
				for await(var i of loop){
					let actor = {
						id: Math.random(),
						actors,
						puppeteer,
						getBrowser(){
							return browser
						},
						available: async function (args){
							var actor = this
							try {
								await actor.page.close()
							} catch (err) {
								global.logger.error("[greenroom][actors][available] Page close errored", err)
							}
							var toDeleteFrom = ['ready', 'actors', 'running']
							for(var from of toDeleteFrom){
								var i = 0
								if(actor.actors[from] instanceof Array){
									for(var thing of actor.actors[from]){
										if(actor.id == thing.id){
											actor.actors[from].splice(i, 1)
										}
										i++
									}
								} else {
									delete actor.actors[from][actor.id]
								}
							}
						},
						pageCrash: async function () {
							global.logger.error("[greenroom][puppeteer][page][error] Page crashed")
							try {
								global.logger.log("[greenroom][puppeteer][page][info] Trying soft page reload")
								await actor.page.reload(); // soft fix
							} catch (recoveringErr) {
									global.logger.error("[greenroom][puppeteer][page][error] Soft page reload didn't work")
									// unable to reload the page, hard fix
									try {
										await actor.browser.close();
									} catch (err) { // browser close was not necessary
											// you might want to log this error
									}
									global.logger.log("[greenroom][puppeteer][browser][info] Launching new browser")
									browser = await actor.puppeteer.launch({ headless: true });
							}							
						}
					}
					actors["ready"].push(actor)
					actors.actors.push(actor)
				}
				this.finding = false
			}
		},
		log(args){
			let prevactors = undefined
			this.log.loop = this.log.loop || setInterval(() => {
				if(prevactors !== this["ready"].length){
					global.logger.log(`[greenroom][actors][info] ${this["ready"].length} ${this["ready"].length == 1 ? 'actor' : 'actors'} ready, ${Object.keys(this["running"]).length} running, ${this.actors.length} in total.`)
					prevactors = this["ready"].length
				}
			}, 100);
			return `${this["ready"].length} ${this["ready"].length == 1 ? 'actor' : 'actors'} ready, ${Object.keys(this["running"]).length} running, ${this.actors.length} in total.`
		}
	}
	

	global.logger.log("[greenroom][actors][info] Initialising actors")
	actors.init(args)

	global.logger.log("[greenroom][actors][info] actors are ready")
	return actors
	
}

